# Основы:
+ [Что такое ЈѴM, JDK, JRE? В чем отличия?](#1-что-такое-јѵm-jdk-jre-в-чем-отличия)
+ [Какие типы данных поддерживает Java? Что такое автоупаковка и автораспаковка?](#2-какие-типы-данных-поддерживает-java-что-такое-автоупаковка-и-автораспаковка)
+ [Что такое String[] args в методе main()?](#3-что-такое-string-args-в-методе-main)
+ []()
+ []()
+ []()
+ []()
+ []()
+ []()
+ []()






# Основы:
### 1. Что такое ЈѴM, JDK, JRE? В чем отличия?
   * > JVM - Java Virtual Machine. Платформа зависимая, работает на определенной платформе, запускает приложения 
   Java.  
   JRE - Java Runtime Environment. Это программа, которая берет ваш Java-код, объединяет его с необходимыми 
   библиотеками и запускает JVM для его выполнения.  
   JDK - Java Development Kit. Бесплатно распространяемый компанией Oracle Corporation комплект разработчика 
   приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры,
   документацию, различные утилиты и исполнительную систему Java.
### 2. Какие типы данных поддерживает Java? Что такое автоупаковка и автораспаковка?
   * > Java поддерживает примитивные и ссылочные типы данных.  
   ***Примитивные тип данных:***  
   Хранят значение, создаются присваиванием значения, имеют строго заданный диапазон допустимых 
   значений, в аргументы методов попадают копии значения переменной (это передача по значению).  
<a id="anchor"></a>
   ![primitive data type.png](Screenshots%2Fprimitive%20data%20type.png)
         1) целые числа (byte, short, int, long);  
         2) числа с плавающей точкой (float, double);  
         3) логический (boolean);  
         4) символьный (char).  
   ***Ссылочные тип данных:***  
   Используются для доступа к объектам (его нельзя получить, если на объект нет ссылки). 
   Хранят адрес объекта в памяти, на который ссылаются (отсюда и название). Создаются через конструкторы классов 
   (присваивание только создаёт вторую ссылку на существующий объект).  
         1) Все классы  
         2) Интерфейсы  
         3) Массивы  
         4) String
   * > ***Автоупаковка*** (Autoboxing) - Это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку 
   всякий раз, когда требуется объект данного типа.  
   ***Автораспаковка*** (Unboxing)- Это преобразование класса-обёртки в соответствующий ему примитивный тип.  
    Если при распаковке класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException.  
    Классы-обёртки неизменяемые, поэтому при каждой автоупаковке (за исключением значений из pool) создается новый 
   объект, что может привести к неразумному расходу памяти.  
   Почитать можно тут -> [Жми...](https://www.bestprog.net/ru/2022/02/05/java-autoboxing-and-auto-unboxing-ru/)  
   ![primitive type wrapper class.png](Screenshots%2Fprimitive%20type%20wrapper%20class.png)
### 3. Что такое String[] args в методе main()?
* >  ***String[] args*** - это просто массив строковых аргументов, которые вы можете передать в метод main() при запуске 
  приложения.  
  ***args*** - это просто имя массива строк.   
  > 
[Содержание](#основы)
### 4. Какими значениями по умолчанию инициализируются поля примитивных типов данных?  
   * > Примитивные типы данных не могут быть null, они инициализируются значениями по умолчанию ([Ответ в таблице](#anchor)).  
***Важный момент*** --> Инициализируются значениями по умолчанию именно переменные объявленные в классе.  
   Если говорить о локальных переменных, о переменных, которые объявлены внутри тела метода, то инициализироваться 
   значениями по умолчанию они не могут. В этом случае получим ошибку на этапе компиляции, что локальная переменная не 
   инициализирована. К локальным переменным нужно обязательно присваивать начальное значение.
### 5. Почему Java не поддерживает указатели, множественное наследование?  
   * >  ***Указатели*** — это переменные, которые указывают непосредственно на адрес объекта, а не значение. Указатель 
   функции напрямую указывает на адрес функции, что может уменьшить потребление памяти. Java не имеет указателей,
   но может эмулировать поведение, используя ссылки на методы или лямбда-выражения. Использование ссылки на метод 
   медленнее, чем прямой вызов метода, но это никак не мешает ее использованию.  
   К сожалению, в Java нет “настоящей” концепции указателей как языках C/C++. Но к счастью для нас, существует обходной 
   путь с использованием ссылок на методы, который близок к реальному. Такой подход позволяет не разработчикам как 
   можно меньше думать об управлении, очистке памяти Почитать можно -> [Тут...](https://javarush.com/groups/posts/3809-kofe-breyk-116-kak-ispoljhzovatjh-ukazateli-funkciy-v-java-indexof-v-java--kak-nayti-indeks-str)
   * > ***Множественное наследование*** – способность создавать классы с множеством классов-родителей. В отличие от 
   других популярных объектно-ориентированных языков, вроде С++, язык Java не поддерживает множественное наследование 
   классов. В Java явное множественное наследование запрещено на уровне синтаксиса языка. Но можно делать множественное
   "наследование" от интерфейсов. А у интерфейсов есть "имплементация методов" (implements).  
   ***extends*** --> У класса только один.  
   ***implements*** --> Может быть у класса много.
      >```Java
      >Пример применения интерфейсов:
      >
      >public class Example {
      >
      >     static public final String str = "23"; /* Класс хронящий в себе значение строки. */
      >}
      >
      >/* Чтобы сделать реализацию методов прямо в интерфейсах (чтобы они не требовали реализации в */
      >/* реализующем их классе),можно использовать ключевое слово default */
      >
      >public interface Child1 {
      >
      >     default char method1() {
      >         return Example.str.charAt(0); /* Возвращяем значение первого инднкса переменной str */
      >     }
      >}
      >
      >public interface Child2 {
      >
      >     default char method2() {
      >         return Example.str.charAt(1); /* Возвращяем значение второго инднкса переменной str */
      >     }
      >}
      >
      >public class Child3 implements Child1, Child2 { /* Класс наследуемый интерфейсы Child1 и Child2. */
      >
      >}
      >
      >public class Main {
      >    public static void main(String[] args) {
      >
      >        Child3 mixIn = new Child3(); /* Создание переменной от класса MixIn. */
      >
      >        System.out.println(mixIn.method1()); /* Запуск метода прописанного в интерфейсе Child1 */
      >        System.out.println(mixIn.method2()); /* Запуск метода прописанного в интерфейсе Child2 */
      >    }
      >}
      > /* Ответ: 2
      >           3 */
### 6. Что такое циклы? Какие типы циклов вы знаете?
   * > ***Цикл*** — это конструкция, которая позволяет многократно выполнять один и тот же участок кода.
   * > В языке Java существует четыре вида циклов:
     > * ### цикл **for**
       >> Цикл for состоит из трех блоков при объявлении цикла:
     >>```Java
     >>for (<начальное действие>; <условие выполнения цикла>; <действие после итерации>) {
     >>     <тело цикла>
     >>}
     > * ### цикл **while** (с предусловием)
       >> Цикл выполняется до тех пор, пока выражение в условии возвращает true перед каждой итерацией.
          В цикле while нельзя не указывать параметр <условие выполнения цикла>, то есть прописывать условие - 
          обязательный пункт.  
          Цикл while называется циклом с предусловием, потому что первый раз условие выполнения проверяется перед первой 
          итерацией. Если проверка вернёт значение false, то ни одна итерация не будет выполнена.  
          Цикл while **обычно используется** в случаях, когда:  
       >> 1) число итераций не известно заранее
       >> 2) счётчик итераций не требуется по логике программы
     >>```Java
     >>while (<условие выполнения цикла>) {
     >>     <тело цикла>
     >>     <действие для прирывания цикла> /* Но действие для прерывания может быть и теле самого цикла. */
     >>}
     > * ### Цикл **do…while** (с постусловием)
       >> Цикл do…while называется циклом с постусловием, потому что выполняет хотя бы одну итерацию, а после этого
     проверяет условие.  
     Сначала отрабатывает действие в <теле цикла>, а потом проверяется <условие выполнения цикла>.
     Если оно возвращает true, то цикл выполнит действие повторно.
     >>```Java
     >>do {
     >>    <тело цикла>
     >>    <действие для прирывания цикла> /* Но действие для прерывания может быть и теле самого цикла. */
     >>} while (<условие выполнения цикла>);
     > * ### цикл **foreach**
     >> Для обхода массива или коллекции. В цикле foreach не нужно следить за счётчиком итераций.
     Цикл foreach сам поочерёдно берёт значения из массива/коллекции и помещает их в указанную перед двоеточием
     переменную.  
     **Важно**, чтобы тип переменной, указанной перед двоеточием, совпадал с типом массива/коллекции перебираемой
     в цикле.
     >>```Java
     >>for (<тип переменной, имя переменной> /* в которую сохраняем найденный элемент */ : <имя массива/коллекции> /* по которому совершаем проход */ ) {
     >>     <тело цикла> /* В ктором совершаем действия с найденным элементом */
     >>}
     > Более подробную информацию о работе с циклами читаем [тут...](https://skillbox.ru/media/base/kak-ispolzovat-tsikly-v-yazyke-java-polnoe-rukovodstvo/?_ga=2.124050826.1638909781.1686215931-1808551533.1686215931&_gl=1%2A1w4kafi%2A_ga%2AMTgwODU1MTUzMy4xNjg2MjE1OTMx%2A_ga_6Z66XBG8S2%2AMTY4NjIxNjUwMC4xLjAuMTY4NjIxNjUwMC42MC4wLjA)
### 7. Как можно организовать бесконечный цикл?
   * > Создать бесконечный цикл легко — достаточно не указывать параметры в цикле for:
     >```Java
     >for (; ;) {<тело цикла>}
     >```
     >С помощью цикла while - достаточно указать в условии выполнения true.
     >```Java
     >while (true) {<тело цикла>}
     >```
     > Сложнее извлечь из этого пользу. Обычно бесконечность цикла – критическая ошибка, которая мешает выполнению 
     >программы. Поэтому каждый цикл стоит проверять на способность корректно завершиться в нужный момент.
### 8. Что такое break, continue и label?
   * > **Использование break и continue дает следующие преимущества:**  
    1) В случае выполнения циклического процесса нет необходимости выполнять лишние итерации, если найдено искомое 
   значение или достигнут нужный результат. Это дает повышение скорости выполнения программы;  
    2) При преждевременном прекращении циклического процесса не искажается структура кода.
   * > * ### **break**:
     >> Оператор break осуществляет выход из блока фигурных скобок { } оператора цикла или оператора switch и передает
     управление следующему оператору в программе. Если используются вложенные циклы, то оператор break осуществляет
     выход из внутреннего цикла, из того цикла, в поле видимости которого он был вызван. При этом внешний цикл 
     продолжит свою работу.  
     Оператор break можно использовать во всех операторах цикла и операторе switch. Другими словами, оператор break не 
     может быть использован за пределами цикла или оператора switch.  
     > * ### **continue**:
     >> Оператор continue применяется в циклах. Оператор continue обеспечивает переход к следующей итерации в цикле.
     Оператор continue можно применять только в циклах. Другими словами, оператор continue нельзя применять за 
     пределами цикла.
     > * ### **label**:
     > label --> Метка.
     >> Оператор break и continue с меткой работает так же, как и оператор goto в других языках программирования. 
        В языке Java оператор goto не используется. Однако, ключевое слово goto зарезервировано. Вместо goto 
        используется оператор break с меткой и оператор continue с меткой, с некоторыми ограничениями.
        Подробнее можно почитать [тут...](https://www.bestprog.net/ru/2018/12/30/operators-break-continue-examples-of-using-ru/#:~:text=Операторы%20break%20с%20меткой%20и,к%20следующей%20итерации%20внешнего%20цикла.)
        , а лучше **никогда этим не пользуйтесь!**
### 9. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
   * > **Пакеты** - это способ организации кода, древовидная структура, **удобная навигация** по коду, где все по папочкам. 
       Организация классов в виде пакетов позволяет **избежать конфликта имен** между классами. Ведь нередки ситуации, 
       когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет гарантировать 
       однозначность имен. С помощью пакетов, модификаторов доступа к пакетам можно влиять на инкапсуляцию кода.
   * > По умолчанию java уже имеет ряд встроенных пакетов, например, java.lang, java.util, java.io и т.д.  
       Именно из пакета java.lang взяты классы System и String для написания первого кода "Hello Word"
### 10. Импортируются ли подпакеты при импорте пакета?
   * > **НЕТ!**  
       Предположим ситуацию:  
       Нужно сделать импорт класса Constructor из пакета reflect. Для этого, под сорокой объявления пакета
       прописываем -> import java.lang.reflect.Constructor . При этом у нас произойдет скачивание класса Constructor из
       пакета reflect. Если прописать import java.lang.reflect.* , то скатаются все классы входящие в пакет reflect, но
       подпакеты находящиеся внутри пакета reflect скачаны не будут! Каждый подпакет импортируется отдельно.
# ООП:  
### 1. Что такое классы / объекты?
   * > **Класс** - является шаблоном или описанием объекта  
       **Объект** - экземпляр класса. Любой объект может обладать двумя основными характеристиками: **состояние** - 
       некоторые данные, которые хранит объект, и **поведение** - действия, которые может совершать объект.  
       Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта 
       в классе применяются методы.
### 2. Что такое инкапсуляция, наследование и полиморфизм? 
   * > * ### Инкапсуляция:  
       >> **Инкапсуляция** описывает идею объединения данных и методов, работающих с этими данными в 
       одном модуле, подобном Java-классу. А еще концепция довольно часто используется для сокрытия внутреннего 
       представления или состояния объекта извне. Доступ к атрибутам класса, если это необходимо, можно дать с 
       помощью **геттеров - чтение** данных и **сеттеров - изменение** данных. Позволяет добиться того, что бв некто не 
       смог сломать рабочую логику нашего приложения. Читаем [тут...](https://proglib.io/p/uchebnik-po-java-inkapsulyaciya-na-prostyh-primerah-2022-08-18)  
       > * ### Наследование:
       >> **Наследование** — это механизм, который позволяет создавать классы на основе других классов. Это дает 
       возможность расширять свойства наследуемого класса, и сохранять работоспособность ранее написанного кода. Кроме 
       этого это позволяет избежать лишнего дублирования кода. Наследование предполагает, что один класс может 
       унаследовать другой. То есть унаследовать его состояние и его метолы. При этом методы переопределяется 
       ***( @Override )*** в дочернем классе.  
       В дочернем классе будет всё то, что есть в родительском классе и плюс  
     • Переопределяем методы.  
     • Добавить свои варианты состояния.  
       Для того чтобы некий класс стал наследником другого класса, в его объявлении применяется ключевое слово extends
       и имя наследуемого класса.  
     • Все классы в мире java, косвенно или прямо, являются наследниками класса Object.   
     • Наследоваться можно только от одного класса.  
       Читаем [тут...](https://metanit.com/java/tutorial/3.5.php)  
       > * ### Полиморфизм:  
       >> **Полиморфизм** - это значит "много форм". Например, актер в театре может примерять на себя много ролей - или 
       принимать "много форм". **Полиморфизм - это** возможность применения одноименных методов с одинаковыми или 
       различными наборами параметров в одном классе или в группе классов, связанных отношением наследования. 
       Полиморфизм помимо работы с классами может быть использован при работе с интерфейсами.  
       Почитать и глянуть на примеры работы полиморфизма можно [тут...](https://javarush.com/groups/posts/polimorfizm-v-java)
### 3. Что такое абстрактный класс? 
   * > **Абстрактный класс** — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих 
       классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое общее 
       состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса. Абстрактный класс 
       — это просто чертеж для будущих «нормальных» классов. Он даёт нам базовое состояние и поведение. Например, 
       у всех машин должна быть модель, цвет и максимальная скорость, а еще они должны уметь газовать и тормозить. 
       Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы.  
       Нельзя создать объект абстрактного класса. Абстрактный класс позволяет создать абстрактные методы. Абстрактные 
       методы - это методы без реализации, методы без тела.
       Почитать можно [тут...](https://javarush.com/groups/posts/1973-abstraktnihe-klassih-v-java-na-konkretnihkh-primerakh) 
       и обязательно [тут...](https://javarush.com/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java) 
### 4. Можно ли создавать абстрактные методы в обычном классе? Создавать обычное методы в абстрактном классе?
   * > **Нельзя.** Абстрактные методы создаются только в абстрактных классах.  
   * > **Можно.** Обычные методы в абстрактных классах создавать можно сколько угодно. Можно создать абстрактный класс
       и организовать его как обычный класс, с обычными методами, полями и т.д. И эта его абстрактность будет влиять 
       только на то, что нельзя будет создать объект этого класса.
### 5. Что такое интерфейс?  
   * > Интерфейс - это абстрактный контракт на выполнение определенных действий. Главная задача — получить нужный 
       результат. Интерфейс описывает поведение, которым должны обладать классы, реализующие этот интерфейс. 
       «Поведение» — это совокупность методов. Если класс реализует интерфейс, но не полностью реализует определенные 
       в нем методы, он должен быть объявлен как abstract.  
       Неплохо по интерфейсы пишут [тут...](https://www.examclouds.com/ru/java/java-core-russian/interfaces)
### 6. Бывают ли пустые интерфейсы?
   * > **Да. Интерфейсы-маркеры** – это интерфейсы, которые не содержат методов. Когда класс наследуется от такого 
       интерфейса, то говорят, что он им помечен. Примеры таких интерфейсов: Cloneable, Serializable, Remote. Наличие 
       реализации интерфейса можно отследить с помощью java.lang.reflect помечая аннотациями. Курс Java_3 Lessen_7.
### 7. Можно ли создать объект: Animal animal = new Flyable();  Если Animal является интерфейсом.
   * > **Нет** - если рассматривать вариант создания объекта как указано в вопросе. Если необходимо создать
       объект / экземпляр от интерфейса или от анонимного класса, то можно воспользоваться конструкцией создания 
       экземпляра анонимного класса:
     >```Java
     >public class TestApp {
     >   public static void main(String[] args) {
     >      Animal animal = new Animal() {
     >         //?
     >         @Override
     >         public void say() {
     >         System.out.println("i am animal");
     >      }
     >   };
     >}
     >
     >   public interface Animal {
     >      void say();
     >   }
     >}
     >```
     > В этом примере анонимный класс (пере)определяет метод say и класс перестаёт быть абстрактным.
### 8. Что означает ключевое слово static? Можно ли переопределить private или static - методы?
   * > * ### static
     >> • **Для полей** - это означает, что поле хранится в классе, принадлежит классу. И если объекты этого класса
        будут к  нему обращаться, то для всех объектов поле static будет общим.  
        • **static метод** - будет означать, что метод статический, он принадлежит классу. Такой метод может работать 
        со статическими полями класса. Напрямую с полями объекта он работать не моет, только через ссылку на сам объект.
        Статические методы можно вызывать без ссылки на объект. На методы, объявленные как static, накладываются 
        следующие ограничения:   
        • Они могут непосредственно вызывать только другие статические методы.  
        • Им непосредственно доступны только статические переменные.  
        • Они не могут делать ссылки типа this или super.  
        Можно глянуть видео материал [тут...](https://www.examclouds.com/ru/java/java-core-russian/static-keyword) (оглавление внизу открывшейся стр.)
     > * ### Можно ли переопределить private или static - методы?
     >> • Нельзя!  
        **private - методы** - у них доступ только внутри самого класса. И соответственно из дочернего класса туда уже
        не добраться.  
        **static - методы** - они принадлежат самому классу. И соответственно по отношению к статическим методам понятие 
        переопределения не применяется. 
### 9. Можно ли получить доступ к нестатическому полю из статического метода? 
   * > * Можно, но только через объект.
### 10. Что такое блок static {}? 
   * > * **static {}?** - Статический блок инициализации, им задают статические переменные (переменные
        класса). Т.е. пишем в классе, вне какого либо метода слово static, 
        открываем скобки и можем там писать какой-то код. Этот блок инициализации выполняется при загрузке класса в 
        память, до создания каких либо объектов, до всего. Если в классе несколько таких блоков, то они выполнятся 
        по очереди, в той последовательности, в какой они объявлены в классе.  
        Еще существует запись -> **{}?** - это обычный блок, им инициализируют внутренние переменные объекта.
        инициализации.
     >```Java
     >public class Car {
     >  static int km;
     >
     >  static {
     >    km = 150;
     >  }
     >}
     >```
### 11. Что такое cast?
  * > * Самого ключевого слова **cast** в языка Java нет, но это подразумевает **приведение типов**, когда есть необходимость 
       представить один тип данных как другой. Приведение типов указывается в круглых скобках перед необходимым для 
       приведения типом.  
       **Пример: int a = 5; float f = (float) a**;
### 12. Что такое переопределение и перегрузка методов? 
* > * **Переопределение** - это возможность реализовать метод так, чтобы он имел идентичную сигнатуру с методом 
класса-родителя, но предоставлял иное поведение, не вызывая коллизий при его использовании. Так же это один из 
инструментов реализации полиморфизма. И когда у этого дочернего метода будет вызываться дочерний метод, то будет
вызываться реализация дочернего класса. К методу родителя можно все ровно получить доступ, но только если классе 
наследнике будет создан отдельный метод, который сможет вызвать родительский метод через _super_. Переопределяя метод — 
обязательно помечайте его аннотацией _@Override_! Читаем и смотрим [тут...](https://ru.hexlet.io/courses/java_101/lessons/override_in_java/theory_unit)
* > * **Перегрузка** это года в одном классе создаются **методы с одинаковыми именами, но с разными параметрами** на 
вход, в метод. При этом эти методы могут возвращать разные типы данных. Перегрузка - это когда нужно сделать методы, 
которые будут делать одно и тоже, но немножечко по-разному, в зависимости от входных данных. Компилятор сам найдет/подключит
нужный метод из списка одноименных на основании переданных данных.
### 13. Что такое конструктор и перегрузка конструктора? Может ли класс иметь несколько конструкторов? 
* > * **Конструктор** - в Java представляют собой специальный блок кода, похожий на метод, предназначенный для 
инициализации полей объекта при его создании. Он вызывается всегда, когда создается новый экземпляр класса. Конструктор
возвращает ссылку на созданный объект. Конструктор "в первой строке" явно или неявно вызывает _super_ - конструктор 
родительского типа.  
**Перегрузка конструктора** - это то же самое, что и перегрузка метода, но только с другими параметрами.  
Всё о конструкторах читаем [тут...](https://topjava.ru/blog/rukovodstvo-po-konstruktoram-v-java)
*  > * **Может**. Нет ограничений на количество конструкторов.
### 14. Когда вызывается конструктор?
* > * Например, при создании объекта.. Конструктор всегда вызывается явно.  Так же стоит отметить, что при десериализации Externalizable
вызывается конструктор. При десериализации Serializable конструктор будет вызываться только в случае, если это был
родительский не Serializable тип который унаследовал тип Serializable - будет вызываться конструктор, а если всё Serializable
то конструктор вызываться не будет. Через интерфейс Reflection конструктор так же может вызываться.
### 15. Поддерживает ли Java множественное наследование? 
* > * Множественные наследования в Java не поддерживаются. Т.е. один клас не может наследоваться от несколько классов
одновременно. Может быть множественное наследование интерфейсов у одного класса. 
### 16. Какие модификаторы доступа вы знаете и сколько их? 
* > * ![access modifiers.jpeg](Screenshots%2Faccess%20modifiers.jpeg)  
 **Четыре модификатора.** Зона видимости классов по модификаторам указана в таблице.
### 17. Что означает ключевое слово this?
* > * _**this**_ - может использоваться внутри любого метода для ссылки на текущий объект. То есть this всегда служит 
ссылкой на объект, для которого был вызван метод. Ключевое слово this можно использовать везде, где допускается ссылка 
на объект типа текущего класса. Используется только вне статическом контексте.
### 18. Что означает ключевое слово super? 
* > * _**super**_ - это ссылка на объект родительского типа. _**super**_ обозначает суперкласс, т. е. класс, производным от
которого является текущий класс. В данном случае, супер не означает превосходство, скорее даже наоборот, дочерний класс
имеет больше методов, чем родительский.
### 19. Что означает ключевое слово final? 
* > * _**final**_ - Модификатор final - предназначен для создания констант. Если мы пропишем **_final_** перед типом данных 
для переменной, то такую переменную нельзя будет изменить в дальнейшем. Если перед классом прописать слово **_final_**, то 
такой класс не сможет иметь никаких классов наследников.  
_Но есть маленький нюанс при использовании Reflection_: Если
final поле создано, но не инициализировано при объявлении, а инициализируем его в конструкторе, то с помощью Reflection 
можно будет изменить значение final поля. Если инициализация происходит при объявлении поля, то даже с помощью
Reflection до этого поля "не добраться". 
### 20. Какой класс является базовым для всех классов? 
* > * **Object** - фактически все классы наследуются от класса Object.
### 21. В чем разница между String, StringBuffer, String Builder? 
* > * **String** – неизменяемая строка. Она финализирована и неизменяема, вследствие этого при любых манипуляциях с 
ними всегда создается новая строка, что делает работу со строками весьма ресурсоёмким процессом. Если строки 
необходимо часто менять, то для этого есть StringBuffer и StringBuilder.
* > * **StringBuffer** — потокобезопасная изменяемая строка. Операции со StringBuffer потокобезопасны и синхронизированы.
Поэтому в случаях, когда несколько потоков должны работать с одной строкой, то необходимо использовать StringBuffer.
* > * **StringBuilder** – изменяемая строка с высокой производительностью, но без синхронизации. В однопоточных 
окружениях желательно использовать StringBuilder, поскольку преимущество StringBuilder перед StringBuffer заключается 
в производительности из-за отсутствия затрат для поддержки синхронизации.
### 22. Может ли метод быть одновременно abstract и final?
* > * **Нет.**  Одновременно abstract и final - противоречат друг другу.  
      _abstract_ метод - не имеет реализации. Обязательно нужно переопределить и он это подразумевает.  
      _final метод_ - нельзя переопределить.  
      _abstract_ класс - подразумевает, что когда-нибудь его унаследует не abstract класс.   
      _final_ класс - нельзя унаследовать.
# Коллекции:
* `В репозитории есть форкнутый репозиторий java-interview. По адресу java-interview /jcf.md доп ответы по коллекциям.`
### 1. Что такое ArrayList и LinkedList, какая между ними разница? 
* > * **ArrayList** это список, реализованный на основе массива.  
     _Преимущества ArrayList:_ в возможности доступа к произвольному элементу по индексу за постоянное время
     (так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка `в среднем`
     производится так же за постоянное время.  `В среднем` потому, что массив имеет определенный начальный размер n 
     (в коде это параметр capacity). **Capacity** - значение, которое указывает ваш зарезервированный объем памяти. 
     Это не фактический размер коллекции, а лишь зарезервированное место в памяти.  
     _Недостатки ArrayList_ проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех 
     элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива 
     не уменьшается, до явного вызова метода trimToSize().
* > * **LinkedList** — это классический двусвязный список, основанный на объектах со ссылками между ними.  
      _LinkedList_ быстро удаляет в начало и в конец списка элементы, за постоянное время может выполнять  
      вставку/удаление элементов в списке (именно вставку и удаление, поиск позиции вставки и удаления сюда не входит).
      Доступ к произвольному элементу осуществляется за 
     линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время — 
     ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе не значит, что 
     придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в абсолютных величинах 
     проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций. LinkedList предпочтительно 
     применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо 
     гарантированное время добавления элемента в список.  
      _LinkedList_ лучше использовать когда необходимо много вставлять/вытаскивать сначала/с конца списка. Удобно 
     использовать как [двусторонняя очередь (Double-ended queue), или дек (Deque)](https://tproger.ru/translations/stacks-and-queues-for-beginners/).
### 2. Что такое Set, HashSet, LinkedHashSet, TreeSet, и в чем между ними разница? 
* > * **Set** - интерфейс наследуется от интерфейса Collection. Этот интерфейс описывает, как должен работать `Set`, 
     оно же множество. `Set` не допускает дублирования элементов.
* > * **HashSet** - реализует интерфейс Set и создает коллекцию, которая хранит элементы в хеш-таблице. `HashSet` 
     реализуется/содержи внутри HashMap. В  HashSet нет дубликатов. Зависимость расположения элементов внутри `HashSet` 
     зависит от вычисленного HashCode в качестве ключа. Ключи могут повторяться, что вызывает `коллизии` - 
     по одному ключу несколько значений. В этом случае необходимое значение по ключу проверяется через `equals()`. 
     Элементы хеш-таблицы хранятся в виде пар ключ-значение. Ключ определяет ячейку 
     (или бакет) для хранения значения. Содержимое ключа служит для определения однозначного значения, называемого 
     хеш-кодом. Можно считать, что хеш-код это ID объекта, хотя он необязательно должен быть уникальным. 
     Этот хеш-код служит далее в качестве индекса, по которому сохраняются данные, связанные с ключом.  
     **Достоинства HashSet:**  
      Выгода от хеширования состоит в том, что оно обеспечивает постоянство время выполнения операций add(), contains(),
      remove() и size(), даже для больших наборов. Сложность выполнения операций будет О(1).  
      **Недостатки HashSet:**  
      (или можно даже сказать особенность) в том, что он не гарантирует упорядоченности элементов, поскольку процесс 
      хеширования сам по себе обычно не приводит к созданию отсортированных множеств. Смотрим [тут...](https://www.examclouds.com/ru/java/java-core-russian/interface-set)
* > * **LinkedHashSet** Класс `LinkedHashSet` языка Java расширяет HashSet, не добавляя никаких новых методов, 
      но запоминает прядок добавления элементов во внутреннюю HashMap\`у.
      `LinkedHashSet` поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет 
      организовать упорядоченную итерацию вставки в набор. Но это приводит к тому, что `LinkedHashSet` выполняет 
      операции дольше и занимает больше памяти, чем класс HashSet.  
      Исходя из выше сказанного `LinkedHashSet` стоит использовать только тогда, когда нам важен прядок добавления элементов.
      Смотрим [тут...](https://www.examclouds.com/ru/java/java-core-russian/interface-set)
* > * **TreeSet** - реализует интерфейс Set, на основе TreeMap. Он создает коллекцию, которая использует красно-черное дерево 
       для хранения. Объекты хранятся в отсортированном порядке по естественному порядку. Реализация TreeSet 
       сортируется по лексикографическому порядку вставляемых строковых значений. По желанию мы можем изменить 
       естественный порядок TreeSet, используя интерфейсы Comparable или Comparator. Кратко [тут...](https://programmera.ru/uroki-po-java/treeset-v-Java/)
### 3. В чем разница между Hashtable и HashMap? 
* > * **Hashtable и HashMap очень похожи** — обе коллекции реализуют интерфейс Map и используют в своей работе 
      коллекцию хеш таблицы.  
      **Различия между Hashtable и HashMap:**  
     >1) Hashtable является потокобезопасным и может совместно использоваться несколькими потоками в приложении. Все 
        методы имеющие доступ к данным - все synchronized. HashMap не синхронизируется, поэтому он быстрее и использует
        меньше памяти, чем Hashtable . Как правило, несинхронизированные объекты работают быстрее, чем 
        синхронизированные, в однопоточном приложении.  
     >2) Другим отличием является нулевая обработка. HashMap позволяет добавить одну запись с нулем в качестве ключа, 
        а также множество записей с нулем в качестве значения. Напротив, Hashtable вообще не допускает null.  
     **Когда выбирать HashMap вместо Hashtable:** Мы должны использовать HashMap для несинхронизированного или 
       однопоточного приложения. Стоит отметить, что начиная `с JDK 1.8 Hashtable устарела`. Однако `ConcurrentHashMap` 
       — отличная замена Hashtable. Мы должны рассмотреть ConcurrentHashMap для использования в приложениях с 
       несколькими потоками.  
       Почитать [тут...](https://for-each.dev/lessons/b/-hashmap-hashtable-differences)
### 4. В чем разница между ArrayList и Vector? 
* > * Оба ArrayList а также Vector представляют собой реализации массива с изменяемым размером List интерфейс. 
      ArrayList примерно эквивалентно Vector и имеют много общего. Подробнее почитать [тут...](https://www.techiedelight.com/ru/arraylist-vs-vector-java/#:~:text=Основное%20различие%20между%20ArrayList%20а,могут%20работать%20над%20ArrayList%20одновременно.)  
      **Различия ArrayList и Vector:**  
    >1) `Синхронизация`. Vector весь синхронизирован, т.е. - потокобезопасный. Если необходимо сделать ArrayList 
      потокобезопасный, его можно синхронизировать извне с помощью Collections.synchronizedList() метод.  
    >2) `Производительность`. Vector очень медленный, поскольку он синхронизирован.  
    >3) `Управление хранилищем`. Оба ArrayList а также Vector может динамически увеличиваться и уменьшаться для 
      размещения новых элементов, если это необходимо. Но, ArrayList увеличивает свой размер наполовину от текущего 
      размера, а Vector удваивает свой размер (забота Java (JVM)).  
    >4) `Безотказность`. Для обхода списка ArrayList использует итератор, а Vector использует как перечисление, так 
      и итератор. Перечисление, возвращаемое векторным методом, `не является отказоустойчивым`.  
      **Кроме этого** - ArrayList всегда должно быть предпочтительнее, чем Vector. А Vector является устаревшим классом,
       который устарел, и его следует избегать любой ценой.
### 5. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?
* > * Ключи в `HashMap` должны правильно реализовывать методы `hashCode()` и `equals()`. Т.е. если два объекта equals(), то 
      у них должен **ОБЯЗАТЕЛЬНО** читаться одинаковый hashCode()! А если hashCode совпадают, то сами объекты необязательно 
      должны быть equals(), т.к. существует такое понятие как коллизия.
      Не требование, но лучше использовать в качестве ключей иммутабельные объекты - такие, как обертки примитивов или 
      String для того, что бы в процессе работы данных в коде, ключ не менял своего значения -> не менялся HashCode -> 
      не "терялась" ячейка/бакет с сохранёнными ранее данными в HashMap.
### 6. Что такое loadFactor и initialCapactity в HashMap? 
* > * Каждый экземпляр класса java.util.HashMap имеет `два параметра` для настройки `производительности` - 
      `начальная емкость (initial capacity)` и `фактор загрузки (load factor)`. Емкость хеш-таблицы - это количество бакетов 
      в ней, а начальная емкость - это то количество бакетов, с которым хеш-таблица создается. Фактор загрузки 
      определяет, насколько должна быть заполнена хеш-таблица перед тем, как автоматически увеличить ее емкость. 
      `По умолчанию, начальная емкость равна 16, а фактор загрузки = 0.75.` Начальная емкость должна быть всегда 
      степенью двойки. Если в конструктор передается начальная емкость, которая не является степенью двойки, 
      то устанавливается не эта неправильная емкость, а ближайшая степень двойки, которая больше этого числа. 
      Это все легко посмотреть по исходникам. Степень двойки для емкости хеш-таблица позволяет некоторые оптимизации, 
      которые положительно влияют на производительность хеш-таблицы. Когда `фактор загрузки превышен`, то хеш-таблица 
      автоматически `увеличивает свою емкость вдвое`.
### 7. Что такое Iterator, чем он отличается от Listiterator? 
* > * `Iterator` а также `ListIterator` два важных интерфейса Java Collection Framework, где ListIterator расширяет 
      Iterator и предоставляет дополнительные возможности по сравнению с Iterator.  
    **Основное различие между Iterator а также ListIterator:**  
    >1) С `Iterator`, мы можем двигаться только вперед, используя его hasNext() а также next() метод в то время как с 
      `ListIterator`, мы можем перемещаться по списку в любом направлении.  
    >2) `ListIterator` позволяет нам изменять список во время итерации, используя его set() метод. Это невозможно с 
      помощью `Iterator`.  
    >3) С использованием `Iterator`, мы не можем получить текущую позицию итератора в списке. С другой стороны, 
      `ListIterator` может возвращать индекс следующего или предыдущего элемента при обходе списка, используя его 
      nextIndex() а также previousIndex(), соответственно.  
      Дополнительно читать [тут...](https://www.techiedelight.com/ru/difference-between-iterator-listiterator-java/#:~:text=Основное%20различие%20между%20Iterator%20а,по%20списку%20в%20любом%20направлении.)
      и [тут...](https://proglang.su/java/iterator-and-listiterator)
### 8. Чем Array отличается от ArrayList? 
* > 1) **Размер:** `Array` в Java имеет фиксированный размер, а у `ArrayList` динамический.  
   >2) **Хранящиеся данные** `Array` в Java могут содержаться примитивные типы данных (int, char, short, long, float, 
      double, boolean) так и объекты (Integer, Character, Long, Float, Double, Boolean, String, так далее.) `ArrayList`
      может содержать только объекты Java.  
   >3) **Итератор** В `ArrayList` мы используем объект `Iterator` для обхода элементов. Для перебора элементов в `Array`
      мы используем `цикл for`.  
   >4) **Безопасность типов** `Array` может содержать объекты одного типа данных. Если мы пытаемся сохранить объект 
      другого типа данных в массиве, он генерирует исключение ArrayStoreException. `ArrayList` использует дженерики, что
      помогает обеспечить безопасность типов данных хранящихся внутри ArrayList.  
   >5) **Длина** размер `ArrayList` можно получить с помощью метода `size()`. Каждый `Array` имеет переменную `length`, 
      которая совпадает с длиной/размером массива.  
   >6) **Добавление элементов** В `ArrayList` мы можем использовать метод `add()` для добавления объектов. 
      В `Array` используется `оператор присваивания` для добавления элементов.  
   >7) **Многомерность** `Array` может быть `многомерным`. `ArrayList` всегда `одномерный`.
   Почитать [тут...](https://java-ru-blog.blogspot.com/2020/11/array-vs-arraylist.html)
### 9. Что такое HashCode()?
* > * **HashCode()** - стандартный метод класса Object, соответственно у всех методов он есть. Возвращает int. Если есть 
      необходимость использовать hashCode объекта в качестве ключа в HashMap и т.п..., то метод HashCode() нужно 
      переопределять.  
      Подробнее [тут...](https://ru.hexlet.io/qna/java/questions/kak-vychislyaetsya-hashcode-java#:~:text=Hashcode%20в%20Java%20вычисляется%20с,Реализация%20алгоритма%20зависит%20от%20JVM.) 
# Исключения: 
### 1. Что означает каждое из ключевых слов: try, catch, finally, throw, throws? 
* >  1) `try` - блок кода в который поменяются операторы для отслеживания/возникновения в них исключений. Если 
      исключение произошло, то оно создаётся и передаётся дальше. 
    >2) `catch` - блок кода, который перехватывает возникшие в try исключения, и обрабатывает эти исключения.
    >3) Любой код, который следует выполнить обязательно. Выполнить в любом случае после завершения блока try, 
        помещается в блок `finally`. Но, если в блоке catch прописать `System.exit(int status);` ,  то блок finally 
        не выполнится. 
    >4) Чтобы передать исключение вручную, используется `throw`.
    >5) Любое исключение, созданное и передаваемое внутри метода, должно быть указано в его интерфейсе ключевым 
        словом `throws`. Т.е. throws прописывается при объявлении метода и указывает, что метод может выбросить 
        определённое исключение.
        Читаем [тут...](https://developer.alexanderklimov.ru/android/java/exception.php)
### 2. Для чего в основном используется блок finally? 
* > * Блок `finally` чаще всего используется для закрытия/высвобождения ресурсов.
### 3. Что такое try-with-resource? 
* > * `try-with-resources` появился в Java 7, и с помощью этой конструкции мы можем объявить ресурсы, которые будут 
       использоваться в try-блоке, и эти ресурсы будут автоматически закрыты по окончании выполнения try-блока. 
       Ресурсом будем называть объект, являющийся экземпляром класса, который реализует интерфейс java.lang.AutoCloseable.
       Смотрим и читаем [тут...](https://www.tune-it.ru/web/vnik/home/-/blogs/java-9-i-try-with-resources)
### 4. Покажите примерную схему дерева классов, наследующихся от Throwable;
* > * ![descendantsOfTheThrowableClass.png](Screenshots%2FdescendantsOfTheThrowableClass.png)
### 5. Что такое checked и unchecked исключения? 
* > * Все исключения делятся на 2 вида — проверяемые (`checked`) и непроверяемые (`unchecked`).
    ![checkedAndUncheckedProperties.png](Screenshots%2FcheckedAndUncheckedProperties.png)
### 6. Что происходит при необработанном исключении? 
* > * В Java `исключения делятся` на контролируемые (`проверяемые`) компилятором и неконтролируемые (`непроверяемые`).
     >1) `Проверяемые исключения` - Исключения, которые обрабатываются компилятором еще на стадии написания/компиляции 
     кода. И если их не обрабатывать, то приложение/код нельзя будет скомпилировать/запустить. Допускается проброс 
     таких исключений, с последующей их обработкой, в вызывающий метод.
     >2) `Непроверяемые` компилятором `исключения` должен контролировать сам программист, т.к. такие исключения 
     проявляют себя в лишь в процессе ее выполнения (runtime), а в процессе написания кода компилятор ничего "не скажет".
### 7. В чем разница между Exception и Error? 
* > * `Exception` - это исключения, которые можно предусмотреть и обработать. Многие такие исключения предлагает 
     обработать компилятор на моменте написания кода.
      `Error` - это ошибки, исправление которых предполагает полный пересмотр и переписывание кода.
### 8. Может ли исключение быть снова брошено после перехвата?
* > * Да. Можно в блоке catch его перехватить и снова там-же бросить.
# Многопоточность: 
### 1. В чем разница между процессом и потоком? 
* > * `Потоки` протекают в процессе, а `процесс`, простыми словами, — это любая запущенная программа. Любой процесс имеет 
      минимум один поток, который называют главным. Он запускается в первую очередь, а остальные идут параллельно.
### 2. Какие существуют способы создания потоков (и сколько их)? 
* > * Поток можно создать двумя способами: унаследовать `класс Thread` или реализовать `интерфейс Runnable`. 
      ‌Вся логика нового треда выполняется в методе run(), а запускается он методом start().
### 3. Какой способ создания потоков предпочтителен? 
* > * `ExecutorService` автоматически предоставляет пул потоков и API для назначения ему задач.  
      Почитать можно [тут...](https://for-each.dev/lessons/b/-java-executor-service-tutorial#:~:text=Самый%20простой%20способ%20создать%20ExecutorService,ExecutorService%20executor%20%3D%20Executors.)
### 4. Что такое Deadlock? 
* > * `Deadlock` - В некорректно спроектированной многопоточной программе может возникнуть ситуация, когда два потока 
       блокируют друг друга. В этом случае их выполнение зависает, пока программу не остановят извне. Такая ситуация 
       называется deadlock.
### 5. В чем разница между notify() и notifyAll()? 
* > *  Оба метода стандартные из класса Object.  
       Дело в том, что «висеть» на методе wait() одного монитора могут сразу несколько потоков. При вызове `notify()` 
       только один из них выходит из wait() и пытается захватить монитор, а затем продолжает работу со следующего 
       после wait() оператора. Какой из них выйдет - заранее неизвестно. А при вызове `notifyAll()`, все висящие на 
       wait() потоки выходят из wait(), и все они пытаются захватить монитор. Понятно, что в любой момент времени 
       монитор может быть захвачен только одним потоком, а остальные ждут своей очереди. Порядок очереди определяется 
       планировщиком потоков Java. 
### 6. В чем разница между sleep() и wait()? 
* > * `wait()` — переводит вызывающий поток в состояние ожидания. Если вызвать wait() в синхронизированном контексте, 
       то поток не только перейдет в режим ожидания, он ещё и освободит монитор. Ожидание продолжается до тех пор, 
       пока другой поток выполнения, который вошел в монитор, не вызовет метод notify().  
    >* `sleep()` - Метод sleep() используется для того, чтобы приостановить выполнение текущего потока на указанное 
       в миллисекундах время. Значение аргумента для миллисекунд не может быть отрицательным, в противном случае будет 
       брошен IllegalArgumentException.  
       Пример: `sleep(long millis);` , а можно передать два аргумента `sleep(long millis, int nanos);` , где int nanos - 
       наносекунды.
       При вызове метода sleep() на потоке - поток приостановит выполнение работы, но при этом поток не освобождает 
       монитор. 
### 7. Можно ли перезапустить завершившийся поток? 
* > * `Конечно нельзя!` `И даже принудительно завершенный  поток перезапустить нельзя!` `start()` - один и тот же 
       поток `несколько раз НЕЛЬЗЯ!` Нужно создать новый экземпляр треда и только тогда его запускать. 
### 8. Какие способы синхронизации вы знаете? 
* > * `synchronized методы`
    >* `блоки synchronized внутри методов`
    >* Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации 
       межпоточного взаимодействия. Примеры таких классов - `Lock, Semaphore` и пр.. Концепция данного подхода 
       заключается в использовании атомарных операций и переменных.  
    Почитать [тут...](https://studfile.net/preview/16556763/page:18/)
### 9. Зачем нужен Semaphore, ExecutorService? 
* > * `Semaphore` - Семафор поддерживает набор разрешений (int permits), каждый acquire() возьму разрешение (permits) 
      с семафора, каждый release() вернет обратно разрешение (permits) обратно на семафор. Если разрешения (permits) 
      не доступны, acquire() будет заблокирован, пока один не доступен. int permits - указывается при создании Semaphore.
    >* `ExecutorService` - это интерфейс, который описывает некие сервисы, позволяющие переиспользовать потоки, т. е. он
       внутри себя создает потоки, а потом динамически закидывает в них задачи. Кроме этого внутри ExecutorService есть 
       очереди в которых хранятся задачи до поступления в работу.   
      Почитать [тут...](https://java-online.ru/concurrent-executor.xhtml)
### 10. Что такое daemon thread?  
* > * Это поток, у которого выставлен флаг `имяПотока.setDaemon(true)` и соответственно, когда в приложении останутся 
      лишь потоки демоны, приложение завершит свою работу. `daemon thread` - поток с низким приоритетом, работающий 
      в фоновом режиме.
# JDBC: 
### 1. Что такое JDBC?
* > * `JDBC (Java DataBase Connectivity — соединение с базами данных на Java)` — платформенно независимый промышленный 
      стандарт взаимодействия Java-приложений с различными СУБД, реализованный в виде пакета java.sql, входящего в 
      состав Java SE.
### 2. Какова роль драйвера в JDBC? 
* > * JDBC основан на концепции так называемых драйверов, позволяющих получать соединение с базой данных по специально 
      описанному URL. Драйверы могут загружаться динамически (во время работы программы). Загрузившись, драйвер сам 
      регистрирует себя и вызывается автоматически, когда программа требует URL, содержащий протокол, за который 
      драйвер отвечает.  
      Почитать можно [тут...](https://itsobes.ru/JavaSobes/chto-takoe-jdbc-draiver-kakie-byvaiut-tipy/)
### 3. Зачем нужен вызов метода Class.forName(...)? 
* > * Нужен для получения ссылки на класс по его полному, строковому имени. Кроме того, что будет получена ссылка на 
      объект типа Class, все данные будут загружены в память. Именно по этому не стоит часто, без необходимости 
      использовать метод Class.forName(...) т.к. память не бесконечна.
### 4. В чем разница между Statement и PreparedStatement?  
* > * JDBC API содержит два основных типа интерфейсов: первый – для разработчиков приложений и второй 
     (более низкого уровня) – для разработчиков драйверов. Соединение с базой данных описывается классом, реализующим 
     интерфейс java.sql.Connection. Имея соединение с базой данных, можно создавать `объекты` типа `Statement`, служащие 
     `для исполнения запросов к базе данных на языке SQL`.   
     `Существуют следующие виды типов Statement:`    
     java.sql.`Statement` — Statement общего назначения. С его помощью можно создавать любые запросы в БД - 
     (INSERT, UPDATE, DELETE, CREATE и т.д.)  
     java.sql.`PreparedStatement` — Statement, служащий для выполнения запросов, содержащих подставляемые параметры, 
     плейсхолдеры (обозначаются символом '?' в теле запроса); 
     Очень не плохо описано [тут...(у меня открывалось только через VPN)](https://proselyte.net/prepared-statement-peculiarities/#:~:text=PreparedStatement%20%E2%80%93%20%D1%8D%D1%82%D0%BE%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%20%D0%B2%20Java,%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B8%20%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%82%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82%20SQL%2D%D0%B8%D0%BD%D1%8A%D0%B5%D0%BA%D1%86%D0%B8%D0%B8.)  
     java.sql.`CallableStatement` — Statement, предназначенный для вызова хранимых процедур. Использует все три  типа 
     параметров: IN, OUT и INOUT. 
     Очень не плохо описано [тут... (у меня открывалось только через VPN)](https://proselyte.net/tutorials/jdbc/stored-procedures/)
### 5. Что такое Connection Pool? 
* > * `Connection Pool` - многопоточный доступ к базе данных. Предположим, что многопоточное приложение, при работе с БД
     должна иметь возможность быстро подключать потоки к БД. При чем, количество этих потоков/подключений заранее
     не известно, но подразумевается их большое количество. Для того, что бы не просадить производительность приложения
     на создание подключения для каждого нового потока - создается пул потоков. В котором уже есть определенное 
     количество созданных подключений, и при необходимости эти созданные и хранящиеся в пуле подключения выдаются новым 
     потокам на подключения к базе данных.  
      `Connection Pool динамический.` Если все открытые соединения уже заняты, создаётся новое. Как только поток 
     освобождает одно из уже существующих соединений, оно становится доступно для других потоков. Если соединение долго 
     не используется, оно закрывается.  
     Почитать [тут...](https://habr.com/ru/articles/101342/#:~:text=Database%20Connection%20Pool%20(dbcp)%20—,открытое%20соединение%20из%20этого%20пула.)
### 6. Что такое ResultSet?  
* > * `Интерфейс java.sql.ResultSet` позволяет легко обрабатывать результаты запроса.  
      `ResultSet` - набор возвращаемых результатов из базы данных, после запроса SELECT. Такой набор можно итерировать 
      и получать данные. 
# Дополнительные вопросы:
### 1. Что такое обобщения? 
* > * `Обобщения (Generic)` - это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, 
      где тип данных указан в виде параметра.  
      Читать [тут...](https://developer.alexanderklimov.ru/android/java/generic.php#:~:text=Обобщения%20%2D%20это%20параметризованные%20типы.,Рассмотрим%20пример%20с%20обобщением.)
### 2. В чем разница между == и equals()? 
* > * `==` для примитивов - сравнивает значения этих примитивов.  
      `==` для объектов - сравнивает ссылки на объект. Получим значение true, если сравниваемые ссылки ссылаются на 
      один и тот же объект.  
      `equals()` - стандартный метод из класса Object, который позволяет сравнить значение объектов так, как вы это 
      запрограммируете.
### 3. Что такое сериализация/десериализация? 
* > * `Сериализация` — это процесс сохранения состояния объекта в последовательность байт. Обычно это используется для 
      передачи по сети, для сохранения состояния программы.
      `Десериализация` — это обратный процесс восстановления объекта из этих байт.  
      В Java за процессы сериализации отвечает интерфейс `Serializable`. Этот интерфейс крайне прост: чтобы им 
      пользоваться, не нужно реализовывать ни одного метода!  
      Стоит почитать [тут...](https://javarush.com/groups/posts/2022-serializacija-i-deserializacija-v-java)
### 4. Что за ключевые слова transient и volatile? 
* > * `transient` — модификатор полей класса в языке Java. Отмеченные этим модификатором поля не записываются в поток 
      байт при применении стандартного алгоритма сериализации. При десериализации объекта такие поля инициализируются 
      значением по умолчанию - null.  
   >* `volatile` -  это один из способов обеспечения доступа к актуальной информации в переменной разными потоками.   
       А конкретнее:  Дело в том, что Java позволяет потокам в целях производительности сохранять локальные копии 
       переменной для каждого потока, который её использует (например в кешах или регистрах процессора). В таком случае 
       после записи другим потоком нового значения в исходную переменную, первый поток будет видеть свою локальную 
       копию со старым значением. Использование ключевого слова `volatile` гарантирует, что все потоки всегда будут 
       использовать общее, исходное значение, и они будут видеть изменения этого исходного значения другими потоками 
       сразу же. Другими словами ключевое слово `volatile` - запрещает потокам кешировать данные об совершённых 
       изменениях в переменной. Почитать можно [тут...](https://urvanov.ru/2017/07/20/зачем-нужно-volatile-в-java/)
### 5. В чем разница между Serializable и Externalizable? 
* > * `interface Serializable` - это автоматическая сериализация и десериализация, и при вызове этого интерфейса нет 
      возможности влиять на эти процессы. процесс «зашит» внутрь Java, и к нему доступа нет, за исключением, при 
      создании полей указать ключевое слово `transient`, и это поле не будет участвовать в процессе сериализации 
      и десериализации.
   > * `interface Externalizable` - дает больше контроля и настраиваемые/изменяемые возможности сериализации и 
      десериализации. При имплементации интерфейса нужно переопределить два метода -  `writeExternal()` и `readExternal()`. 
      Читаем [тут...](https://javarush.com/groups/posts/2023-znakomstvo-s-interfeysom-externalizable)
### 6. Необходим ли установленный JDK для запуска Java-программ? 
* > * `Нет`, JDK только для запуска Java программ не обязательна, НО `обязательна для запуска JRE`. JDK - необходима для 
      написания кода и компиляции. Подробнее [тут...](https://topjava.ru/blog/what-is-the-jre)
### 7. Можно ли в интерфейсе объявить статический метод?
* > * Начиная с Java 8, вы можете включать в интерфейсы статические методы. Метод, объявляемый как static в интерфейсе, 
      можно вызывать независимо от любого объекта. Для этого метод должен быть определен в интерфейсе. Чтобы обратиться 
      к статическому методу интерфейса также, как и в случае с классами, пишут название интерфейса и метод:
   >```Java
   >interface Printable {
   >   void print();
   >   static void read(){
   >      System.out.println("Read printable");
   >   }
   >}
   >
   >public static void main(String[] args) {
   >   Printable.read();
   >}
### 8. Можно ли увеличить размер массива после его инициализации?
* > * Нет, нельзя. Можно создать новый, больший массив и скопировать в него данные.
### 9. Что такое локальный класс? 
* > * Это класс объявленный внутри метода.
### 10. Что такое сборщик мусора (Garbage Collector)? 
* > * `Garbage Collector` - специальная функция встроенная в Java периодически освобождающая память, удаляя из 
      неё ставшие ненужными, не используемые объекты. Подробнее [тут...](https://java-online.ru/garbage-collection.xhtml)
### 11. Что означает иммутабельность String? 
* > * Иммутабельность - не изменяемость.   
      После создания объекта String: 
   >1) Класс String - final. Его нельзя унаследовать.
   >2) В классе String - нет сеттеров.
   >3) Никак не получить ссылку на внутренний массив в стринге.
   >4) Сам массив String - final. 
   >5) Невозможно изменить состояние объекта, созданный массив String
       Иммутабельный клас - после создания объекта которого, этот объект реально никак не изменить.
       <a Текст ссылки="твоё_название"></a>
### 12. Как создать собственный иммутабельный класс? 
* > * Нужно исключить:
     >1) Исключить наследование.
     >2) Исключить любые сеттеры.
     >3) Если внутри класса используются какие-либо ссылочные типы данных и их получают в конструкторе, то в таком 
         случае эти ссылочные типы не нужно использовать как они есть, а использовать их копии. Читаем [тут...](https://itsobes.ru/JavaSobes/kak-napisat-immutabelnyi-klass/)
### 13. В чем разница между набором классов Reader/Writer и InputStream/OutputStream?
* > + `InputStream` и его наследники - совокупность для получения байтовых данных из различных источников;
   >+ `OutputStream` и его наследники - набор классов, определяющих потоковый байтовый вывод;
   >+ `Reader` и его наследники определяют потоковый ввод символов Unicode;
   >+ `Writer` и его наследники определяют потоковый вывод символов Unicode.  
   Почитать можно [тут...](https://github.com/enhorse/java-interview/blob/master/io.md#Чем-отличаются-и-что-общего-у-inputstream-outputstream-reader-writer)  
      [Текст ссылки](#твоё_название)