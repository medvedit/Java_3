# Основы:
### 1. Что такое ЈѴM, JDK, JRE? В чем отличия?
   * > JVM - Java Virtual Machine. Платформа зависимая, работает на определенной платформе, запускает приложения 
   Java.  
   JRE - Java Runtime Environment. Это программа, которая берет ваш Java-код, объединяет его с необходимыми 
   библиотеками и запускает JVM для его выполнения.  
   JDK - Java Development Kit. Бесплатно распространяемый компанией Oracle Corporation комплект разработчика 
   приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры,
   документацию, различные утилиты и исполнительную систему Java.
### 2. Какие типы данных поддерживает Java? Что такое автоупаковка и автораспаковка?
   * > Java поддерживает примитивные и ссылочные типы данных.  
   ***Примитивные переменные:***  
   Хранят значение, создаются присваиванием значения, имеют строго заданный диапазон допустимых 
   значений, в аргументы методов попадают копии значения переменной (это передача по значению).  
         1) целые числа (byte, short, int, long);  
         2) числа с плавающей точкой (float, double);  
         3) логический (boolean);  
         4) символьный (char).  
   ***Ссылочные переменные:***  
   Используются для доступа к объектам (его нельзя получить, если на объект нет ссылки). 
   Хранят адрес объекта в памяти, на который ссылаются (отсюда и название). Создаются через конструкторы классов 
   (присваивание только создаёт вторую ссылку на существующий объект).  
         1) Все классы  
         2) Интерфейсы  
         3) Массивы  
         4) String
<a id="anchor"></a>
   ![screenshot 2023-06-06 в 16.03.20.png](screenshot%202023-06-06%20%D0%B2%2016.03.20.png)
   * > ***Автоупаковка*** (Autoboxing) - Это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку 
   всякий раз, когда требуется объект данного типа.  
   ***Автораспаковка*** (Unboxing)- Это преобразование класса-обёртки в соответствующий ему примитивный тип.  
    Если при распаковке класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException.  
    Классы-обёртки неизменяемые, поэтому при каждой автоупаковке (за исключением значений из pool) создается новый 
   объект, что может привести к неразумному расходу памяти.  
   Почитать можно тут -> [Жми...](https://www.bestprog.net/ru/2022/02/05/java-autoboxing-and-auto-unboxing-ru/)  
   ![screenshot 2023-06-06 в 17.35.38.png](screenshot%202023-06-06%20%D0%B2%2017.35.38.png)
### 3. Что такое String[] args в методе main()?
* >  ***String[] args*** - это просто массив строковых аргументов, которые вы можете передать в метод main() при запуске 
  приложения.  
  ***args*** - это просто имя массива строк.  
### 4. Какими значениями по умолчанию инициализируются поля примитивных типов данных?  
   * > Примитивные типы данных не могут быть null, они инициализируются значениями по умолчанию ([Ответ в таблице](#anchor)).  
***Важный момент*** --> Инициализируются значениями по умолчанию именно переменные объявленные в классе.  
   Если говорить о локальных переменных, о переменных, которые объявлены внутри тела метода, то инициализироваться 
   значениями по умолчанию они не могут. В этом случае получим ошибку на этапе компиляции, что локальная переменная не 
   инициализирована. К локальным переменным нужно обязательно присваивать начальное значение.
### 5. Почему Java не поддерживает указатели, множественное наследование?  
   * >  ***Указатели*** — это переменные, которые указывают непосредственно на адрес объекта, а не значение. Указатель 
   функции напрямую указывает на адрес функции, что может уменьшить потребление памяти. Java не имеет указателей,
   но может эмулировать поведение, используя ссылки на методы или лямбда-выражения. Использование ссылки на метод 
   медленнее, чем прямой вызов метода, но это никак не мешает ее использованию.  
   К сожалению, в Java нет “настоящей” концепции указателей как языках C/C++. Но к счастью для нас, существует обходной 
   путь с использованием ссылок на методы, который близок к реальному. Такой подход позволяет не разработчикам как 
   можно меньше думать об управлении, очистке памяти Почитать можно -> [Тут...](https://javarush.com/groups/posts/3809-kofe-breyk-116-kak-ispoljhzovatjh-ukazateli-funkciy-v-java-indexof-v-java--kak-nayti-indeks-str)
   * > ***Множественное наследование*** – способность создавать классы с множеством классов-родителей. В отличие от 
   других популярных объектно-ориентированных языков, вроде С++, язык Java не поддерживает множественное наследование 
   классов. В Java явное множественное наследование запрещено на уровне синтаксиса языка. Но можно делать множественное
   "наследование" от интерфейсов. А у интерфейсов есть "имплементация методов" (implements).  
   ***extends*** --> У класса только один.  
   ***implements*** --> Может быть у класса много.
      >```Java
      >Пример применения интерфейсов:
      >
      >public class Example {
      >
      >     static public final String str = "23"; /* Класс хронящий в себе значение строки. */
      >}
      >
      >/* Чтобы сделать реализацию методов прямо в интерфейсах (чтобы они не требовали реализации в */
      >/* реализующем их классе),можно использовать ключевое слово default */
      >
      >public interface Child1 {
      >
      >     default char method1() {
      >         return Example.str.charAt(0); /* Возвращяем значение первого инднкса переменной str */
      >     }
      >}
      >
      >public interface Child2 {
      >
      >     default char method2() {
      >         return Example.str.charAt(1); /* Возвращяем значение второго инднкса переменной str */
      >     }
      >}
      >
      >public class Child3 implements Child1, Child2 { /* Класс наследуемый интерфейсы Child1 и Child2. */
      >
      >}
      >
      >public class Main {
      >    public static void main(String[] args) {
      >
      >        Child3 mixIn = new Child3(); /* Создание переменной от класса MixIn. */
      >
      >        System.out.println(mixIn.method1()); /* Запуск метода прописанного в интерфейсе Child1 */
      >        System.out.println(mixIn.method2()); /* Запуск метода прописанного в интерфейсе Child2 */
      >    }
      >}
      > /* Ответ: 2
      >           3 */
### 6. Что такое циклы? Какие типы циклов вы знаете?
   * > ***Цикл*** — это конструкция, которая позволяет многократно выполнять один и тот же участок кода.
   * > В языке Java существует четыре вида циклов:
     > * ### цикл **for**
       >> Цикл for состоит из трех блоков при объявлении цикла:
     >>```Java
     >>for (<начальное действие>; <условие выполнения цикла>; <действие после итерации>) {
     >>     <тело цикла>
     >>}
     > * ### цикл **while** (с предусловием)
       >> Цикл выполняется до тех пор, пока выражение в условии возвращает true перед каждой итерацией.
          В цикле while нельзя не указывать параметр <условие выполнения цикла>, то есть прописывать условие - 
          обязательный пункт.  
          Цикл while называется циклом с предусловием, потому что первый раз условие выполнения проверяется перед первой 
          итерацией. Если проверка вернёт значение false, то ни одна итерация не будет выполнена.  
          Цикл while **обычно используется** в случаях, когда:  
       >> 1) число итераций не известно заранее
       >> 2) счётчик итераций не требуется по логике программы
     >>```Java
     >>while (<условие выполнения цикла>) {
     >>     <тело цикла>
     >>     <действие для прирывания цикла> /* Но действие для прерывания может быть и теле самого цикла. */
     >>}
     > * ### Цикл **do…while** (с постусловием)
       >> Цикл do…while называется циклом с постусловием, потому что выполняет хотя бы одну итерацию, а после этого
     проверяет условие.  
     Сначала отрабатывает действие в <теле цикла>, а потом проверяется <условие выполнения цикла>.
     Если оно возвращает true, то цикл выполнит действие повторно.
     >>```Java
     >>do {
     >>    <тело цикла>
     >>    <действие для прирывания цикла> /* Но действие для прерывания может быть и теле самого цикла. */
     >>} while (<условие выполнения цикла>);
     > * ### цикл **foreach**
     >> Для обхода массива или коллекции. В цикле foreach не нужно следить за счётчиком итераций.
     Цикл foreach сам поочерёдно берёт значения из массива/коллекции и помещает их в указанную перед двоеточием
     переменную.  
     **Важно**, чтобы тип переменной, указанной перед двоеточием, совпадал с типом массива/коллекции перебираемой
     в цикле.
     >>```Java
     >>for (<тип переменной, имя переменной> /* в которую сохраняем найденный элемент */ : <имя массива/коллекции> /* по которому совершаем проход */ ) {
     >>     <тело цикла> /* В ктором совершаем действия с найденным элементом */
     >>}
     > Более подробную информацию о работе с циклами читаем [тут...](https://skillbox.ru/media/base/kak-ispolzovat-tsikly-v-yazyke-java-polnoe-rukovodstvo/?_ga=2.124050826.1638909781.1686215931-1808551533.1686215931&_gl=1%2A1w4kafi%2A_ga%2AMTgwODU1MTUzMy4xNjg2MjE1OTMx%2A_ga_6Z66XBG8S2%2AMTY4NjIxNjUwMC4xLjAuMTY4NjIxNjUwMC42MC4wLjA)
### 7. Как можно организовать бесконечный цикл?
   * > Создать бесконечный цикл легко — достаточно не указывать параметры в цикле for:
     >```Java
     >for (; ;) {<тело цикла>}
     >```
     >С помощью цикла while - достаточно указать в условии выполнения true.
     >```Java
     >while (true) {<тело цикла>}
     >```
     > Сложнее извлечь из этого пользу. Обычно бесконечность цикла – критическая ошибка, которая мешает выполнению 
     >программы. Поэтому каждый цикл стоит проверять на способность корректно завершиться в нужный момент.
### 8. Что такое break, continue и label?
   * > **Использование break и continue дает следующие преимущества:**  
    1) В случае выполнения циклического процесса нет необходимости выполнять лишние итерации, если найдено искомое 
   значение или достигнут нужный результат. Это дает повышение скорости выполнения программы;  
    2) При преждевременном прекращении циклического процесса не искажается структура кода.
   * > * ### **break**:
     >> Оператор break осуществляет выход из блока фигурных скобок { } оператора цикла или оператора switch и передает
     управление следующему оператору в программе. Если используются вложенные циклы, то оператор break осуществляет
     выход из внутреннего цикла, из того цикла, в поле видимости которого он был вызван. При этом внешний цикл 
     продолжит свою работу.  
     Оператор break можно использовать во всех операторах цикла и операторе switch. Другими словами, оператор break не 
     может быть использован за пределами цикла или оператора switch.  
     > * ### **continue**:
     >> Оператор continue применяется в циклах. Оператор continue обеспечивает переход к следующей итерации в цикле.
     Оператор continue можно применять только в циклах. Другими словами, оператор continue нельзя применять за 
     пределами цикла.
     > * ### **label**:
     > label --> Метка.
     >> Оператор break и continue с меткой работает так же, как и оператор goto в других языках программирования. 
        В языке Java оператор goto не используется. Однако, ключевое слово goto зарезервировано. Вместо goto 
        используется оператор break с меткой и оператор continue с меткой, с некоторыми ограничениями.
        Подробнее можно почитать [тут...](https://www.bestprog.net/ru/2018/12/30/operators-break-continue-examples-of-using-ru/#:~:text=Операторы%20break%20с%20меткой%20и,к%20следующей%20итерации%20внешнего%20цикла.)
        , а лучше **никогда этим не пользуйтесь!**
### 9. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
   * > **Пакеты** - это способ организации кода, древовидная структура, **удобная навигация** по коду, где все по папочкам. 
       Организация классов в виде пакетов позволяет **избежать конфликта имен** между классами. Ведь нередки ситуации, 
       когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет гарантировать 
       однозначность имен. С помощью пакетов, модификаторов доступа к пакетам можно влиять на инкапсуляцию кода.
   * > По умолчанию java уже имеет ряд встроенных пакетов, например, java.lang, java.util, java.io и т.д.  
       Именно из пакета java.lang взяты классы System и String для написания первого кода "Hello Word"
### 10. Импортируются ли подпакеты при импорте пакета?
   * > **НЕТ!**  
       Предположим ситуацию:  
       Нужно сделать импорт класса Constructor из пакета reflect. Для этого, под сорокой объявления пакета
       прописываем -> import java.lang.reflect.Constructor . При этом у нас произойдет скачивание класса Constructor из
       пакета reflect. Если прописать import java.lang.reflect.* , то скатаются все классы входящие в пакет reflect, но
       подпакеты находящиеся внутри пакета reflect скачаны не будут! Каждый подпакет импортируется отдельно.
# ООП:  
### 1. Что такое классы / объекты?
   * > **Класс** - является шаблоном или описанием объекта  
       **Объект** - экземпляр класса. Любой объект может обладать двумя основными характеристиками: **состояние** - 
       некоторые данные, которые хранит объект, и **поведение** - действия, которые может совершать объект.  
       Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта 
       в классе применяются методы.
### 2. Что такое инкапсуляция, наследование и полиморфизм? 
   * > * ### Инкапсуляция:  
       >> **Инкапсуляция** описывает идею объединения данных и методов, работающих с этими данными в 
       одном модуле, подобном Java-классу. А еще концепция довольно часто используется для сокрытия внутреннего 
       представления или состояния объекта извне. Доступ к атрибутам класса, если это необходимо, можно дать с 
       помощью **геттеров - чтение** данных и **сеттеров - изменение** данных. Позволяет добиться того, что бв некто не 
       смог сломать рабочую логику нашего приложения. Читаем [тут...](https://proglib.io/p/uchebnik-po-java-inkapsulyaciya-na-prostyh-primerah-2022-08-18)  
       > * ### Наследование:
       >> **Наследование** — это механизм, который позволяет создавать классы на основе других классов. Это дает 
       возможность расширять свойства наследуемого класса, и сохранять работоспособность ранее написанного кода. Кроме 
       этого это позволяет избежать лишнего дублирования кода. Наследование предполагает, что один класс может 
       унаследовать другой. То есть унаследовать его состояние и его метолы. При этом методы переопределяется 
       ***( @Override )*** в дочернем классе.  
       В дочернем классе будет всё то, что есть в родительском классе и плюс  
     • Переопределяем методы.  
     • Добавить свои варианты состояния.  
       Для того чтобы некий класс стал наследником другого класса, в его объявлении применяется ключевое слово extends
       и имя наследуемого класса.  
     • Все классы в мире java, косвенно или прямо, являются наследниками класса Object.   
     • Наследоваться можно только от одного класса.  
       Читаем [тут...](https://metanit.com/java/tutorial/3.5.php)  
       > * ### Полиморфизм:  
       >> **Полиморфизм** - это значит "много форм". Например, актер в театре может примерять на себя много ролей - или 
       принимать "много форм". **Полиморфизм - это** возможность применения одноименных методов с одинаковыми или 
       различными наборами параметров в одном классе или в группе классов, связанных отношением наследования. 
       Полиморфизм помимо работы с классами может быть использован при работе с интерфейсами.  
       Почитать и глянуть на примеры работы полиморфизма можно [тут...](https://javarush.com/groups/posts/polimorfizm-v-java)
### 3. Что такое абстрактный класс? 
   * > **Абстрактный класс** — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих 
       классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое общее 
       состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса. Абстрактный класс 
       — это просто чертеж для будущих «нормальных» классов. Он даёт нам базовое состояние и поведение. Например, 
       у всех машин должна быть модель, цвет и максимальная скорость, а еще они должны уметь газовать и тормозить. 
       Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы.  
       Нельзя создать объект абстрактного класса. Абстрактный класс позволяет создать абстрактные методы. Абстрактные 
       методы - это методы без реализации, методы без тела.
       Почитать можно [тут...](https://javarush.com/groups/posts/1973-abstraktnihe-klassih-v-java-na-konkretnihkh-primerakh) 
       и обязательно [тут...](https://javarush.com/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java) 
### 4. Можно ли создавать абстрактные методы в обычном классе? Создавать обычное методы в абстрактном классе?
   * > **Нельзя.** Абстрактные методы создаются только в абстрактных классах.  
   * > **Можно.** Обычные методы в абстрактных классах создавать можно сколько угодно. Можно создать абстрактный класс
       и организовать его как обычный класс, с обычными методами, полями и т.д. И эта его абстрактность будет влиять 
       только на то, что нельзя будет создать объект этого класса.
### 5. Что такое интерфейс?  
   * > Интерфейс - это абстрактный контракт на выполнение определенных действий. Главная задача — получить нужный 
       результат. Интерфейс описывает поведение, которым должны обладать классы, реализующие этот интерфейс. 
       «Поведение» — это совокупность методов. Если класс реализует интерфейс, но не полностью реализует определенные 
       в нем методы, он должен быть объявлен как abstract.  
       Неплохо по интерфейсы пишут [тут...](https://www.examclouds.com/ru/java/java-core-russian/interfaces)
### 6. Бывают ли пустые интерфейсы?
   * > **Да. Интерфейсы-маркеры** – это интерфейсы, которые не содержат методов. Когда класс наследуется от такого 
       интерфейса, то говорят, что он им помечен. Примеры таких интерфейсов: Cloneable, Serializable, Remote. Наличие 
       реализации интерфейса можно отследить с помощью java.lang.reflect помечая аннотациями. Курс Java_3 Lessen_7.
### 7. Можно ли создать объект: Animal animal = new Flyable();  Если Animal является интерфейсом.
   * > **Нет** - если рассматривать вариант создания объекта как указано в вопросе. Если необходимо создать
       объект / экземпляр от интерфейса или от анонимного класса, то можно воспользоваться конструкцией создания 
       экземпляра анонимного класса:
     >```Java
     >public class TestApp {
     >   public static void main(String[] args) {
     >      Animal animal = new Animal() {
     >         //?
     >         @Override
     >         public void say() {
     >         System.out.println("i am animal");
     >      }
     >   };
     >}
     >
     >   public interface Animal {
     >      void say();
     >   }
     >}
     >```
     > В этом примере анонимный класс (пере)определяет метод say и класс перестаёт быть абстрактным.
### 8. Что означает ключевое слово static? Можно ли переопределить private или static - методы?
   * > * ### static
     >> • **Для полей** - это означает, что поле хранится в классе, принадлежит классу. И если объекты этого класса
        будут к  нему обращаться, то для всех объектов поле static будет общим.  
        • **static метод** - будет означать, что метод статический, он принадлежит классу. Такой метод может работать 
        со статическими полями класса. Напрямую с полями объекта он работать не моет, только через ссылку на сам объект.
        Статические методы можно вызывать без ссылки на объект. На методы, объявленные как static, накладываются 
        следующие ограничения:   
        • Они могут непосредственно вызывать только другие статические методы.  
        • Им непосредственно доступны только статические переменные.  
        • Они не могут делать ссылки типа this или super.  
        Можно глянуть видео материал [тут...](https://www.examclouds.com/ru/java/java-core-russian/static-keyword) (оглавление внизу открывшейся стр.)
     > * ### Можно ли переопределить private или static - методы?
     >> • Нельзя!  
        **private - методы** - у них доступ только внутри самого класса. И соответственно из дочернего класса туда уже
        не добраться.  
        **static - методы** - они принадлежат самому классу. И соответственно по отношению к статическим методам понятие 
        переопределения не применяется. 
### 9. Можно ли получить доступ к нестатическому полю из статического метода? 
   * > * Можно, но только через объект.
### 10. Что такое блок static {}? 
   * > * **static {}?** - Статический блок инициализации, им задают статические переменные (переменные
        класса). Т.е. пишем в классе, вне какого либо метода слово static, 
        открываем скобки и можем там писать какой-то код. Этот блок инициализации выполняется при загрузке класса в 
        память, до создания каких либо объектов, до всего. Если в классе несколько таких блоков, то они выполнятся 
        по очереди, в той последовательности, в какой они объявлены в классе.  
        Еще существует запись -> **{}?** - это обычный блок, им инициализируют внутренние переменные объекта.
        инициализации.
     >```Java
     >public class Car {
     >  static int km;
     >
     >  static {
     >    km = 150;
     >  }
     >}
     >```
### 11. Что такое cast?
  * > * Самого ключевого слова **cast** в языка Java нет, но это подразумевает **приведение типов**, когда есть необходимость 
       представить один тип данных как другой. Приведение типов указывается в круглых скобках перед необходимым для 
       приведения типом.  
       **Пример: int a = 5; float f = (float) a**;
### 12. Что такое переопределение и перегрузка методов? 
* > * **Переопределение** - это возможность реализовать метод так, чтобы он имел идентичную сигнатуру с методом 
класса-родителя, но предоставлял иное поведение, не вызывая коллизий при его использовании. Так же это один из 
инструментов реализации полиморфизма. И когда у этого дочернего метода будет вызываться дочерний метод, то будет
вызываться реализация дочернего класса. К методу родителя можно все ровно получить доступ, но только если классе 
наследнике будет создан отдельный метод, который сможет вызвать родительский метод через _super_. Переопределяя метод — 
обязательно помечайте его аннотацией _@Override_! Читаем и смотрим [тут...](https://ru.hexlet.io/courses/java_101/lessons/override_in_java/theory_unit)
* > * **Перегрузка** это года в одном классе создаются **методы с одинаковыми именами, но с разными параметрами** на 
вход, в метод. При этом эти методы могут возвращать разные типы данных. Перегрузка - это когда нужно сделать методы, 
которые будут делать одно и тоже, но немножечко по-разному, в зависимости от входных данных. Компилятор сам найдет/подключит
нужный метод из списка одноименных на основании переданных данных.
### 13. Что такое конструктор и перегрузка конструктора? Может ли класс иметь несколько конструкторов? 
* > * **Конструктор** - в Java представляют собой специальный блок кода, похожий на метод, предназначенный для 
инициализации полей объекта при его создании. Он вызывается всегда, когда создается новый экземпляр класса. Конструктор
возвращает ссылку на созданный объект. Конструктор "в первой строке" явно или неявно вызывает _super_ - конструктор 
родительского типа.  
**Перегрузка конструктора** - это то же самое, что и перегрузка метода, но только с другими параметрами.  
Всё о конструкторах читаем [тут...](https://topjava.ru/blog/rukovodstvo-po-konstruktoram-v-java)
*  > * **Может**. Нет ограничений на количество конструкторов.
### 14. Когда вызывается конструктор?
* > * Например, при создании объекта.. Конструктор всегда вызывается явно.  Так же стоит отметить, что при десериализации Externalizable
вызывается конструктор. При десериализации Serializable конструктор будет вызываться только в случае, если это был
родительский не Serializable тип который унаследовал тип Serializable - будет вызываться конструктор, а если всё Serializable
то конструктор вызываться не будет. Через интерфейс Reflection конструктор так же может вызываться.
### 15. Поддерживает ли Java множественное наследование? 
* > * Множественные наследования в Java не поддерживаются. Т.е. один клас не может наследоваться от несколько классов
одновременно. Может быть множественное наследование интерфейсов у одного класса. 
### 16. Какие модификаторы доступа вы знаете и сколько их? 
* > * ![Access Modifiers.jpeg](Access%20Modifiers.jpeg)  
 Четыре модификатора. Зона видимости классов по модификаторам указана в таблице.
### 17. Что означает ключевое слово this? 
### 18. Что означает ключевое слово super? 
### 19. Что означает ключевое слово final? 
### 20. Какой класс является базовым для всех классов? 
### 21. В чем разница между String, StringBuffer, String Builder? 
### 22. Может ли метод быть одновременно abstract и final?